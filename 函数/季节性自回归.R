###### 孙中山蒋介石/毛泽东，大秦赋，黄埔军校，中科红旗Asianux兵工厂 #######
##
######## 中科红旗，除巫砸倭 ########
######## 秦皇嬴政，笑傲江湖 ########
######## 三军未动，粮草先行 ########
######## 一带一路，泛亚高铁 ########
######## 不忘初心，方得始终 ########
##
######## 千古一帝，秦皇嬴政 ########
######## 敌在东盟，统一亚洲 ########
######## 咸阳出发，西征欧非 ########
######## 青出于蓝，而胜于蓝 ########
######## 红出于青，更胜于清 ########
######## 中科红旗，更胜英蒙 ########
######## 横跨七洲，秦灭六洲 ########
######## 史无前例，一统天下 ########
######## 三军未动，粮草先行 ########
######## 一带一路，泛亚高铁 ########
######## 不忘初心，放得始终 ########
##
## 东亚孙文，铲除回族，走向共和。
## 东盟孙武，铲除巫裔，千古一帝。
##

季节性自回归 <- function(
    ## ======== 居住在英国布里斯托尔港口，修读气象学系的英国基督洋妞儿芈拉不可以死 ========
    时间索引, 样本, .蜀道 = NULL, 文件名 = '季节性自回归', 数据量, 频率 = 1200, 
    预测时间单位 = 1, .模型选项 = .模型选项, .差分阶数 = .差分阶数, 
    .季节性差分阶数 = .季节性差分阶数, 季节性与否 = 季节性与否, 
    .时序规律 = .时序规律, .季节性规律参数 = .季节性规律参数, 
    静态与否 = 静态与否, 记载自回归与否 = 记载自回归与否, 
    信息量准则 = 信息量准则, 逐步精化与否 = 逐步精化与否, 
    逐步精化量 = 逐步精化量, 
    #近似值与否 = (length(x) > 150 | frequency(x) > 12), 
    缩写 = 缩写, #x = y, method = NULL, 
    ## 代码中xreg作为 [公式] 。xreg可以指定多组相关序列，
    ##   也就是说动态回归就是多元回归。
    ## Dynamic Harmonic Regression
    ## 使用FT（傅里叶）序列作为xreg。模型拟合时不指定seasonal，
    ##   在预测时加入周期性的xreg（势头/趋势/气势）。
    ## [R语言时间序列分析（预测）](https://zhuanlan.zhihu.com/p/29755934)
    趋势 = 趋势, 测试 = 测试, 测试参数 = 测试参数, 
    季节性测试 = 季节性测试, 季节性测试参数 = 季节性测试参数, 
    允许截距与否 = 允许截距与否, 允许包含均值与否 = 允许包含均值与否, 
    博克斯考克斯变换 = 博克斯考克斯变换, 偏差调整与否 = 偏差调整与否, 
    多管齐下与否 = 多管齐下与否, 核心量 = 核心量, 
    包含均值与否 = 包含均值与否, #趋势 = NULL, 包含常数与否, 
    包含截距 = 包含截距, 统计模型 = 统计模型, 
    #博克斯考克斯变换 = 统计模型$lambda, x = y, 偏差调整与否 = FALSE, 
    计策谋略 = 计策谋略) {
  
  options(digits = 30)
  require('tidyft', quietly = TRUE)
  require('forecast', quietly = TRUE)
  conflict_prefer('mutate_dt', 'tidyft', quiet = TRUE)
  conflict_prefer('rename_dt', 'tidyft', quiet = TRUE)
  conflict_prefer('select_dt', 'tidyft', quiet = TRUE)
  
  if (!'data.table' %in% class(样本)) 样本 %<>% as.data.table
  
  if (!exists('.蜀道') || is.null(.蜀道)) {
    .蜀道 <- getwd() |> 
      {\(.) str_split(., '/')}() |> 
      {\(.) c('/', .[[1]][2:5])}() |> 
      {\(.) c(., 'binary.com-interview-question-data/')}() |> 
      {\(.) paste(., collapse = '/')}() |> 
      {\(.) substring(., 2)}()
  }
  .蜀道仓库 <- paste0(.蜀道, '文艺数据库/fx/USDJPY/仓库/')
  .模型选项表 = c('自动化', '自回归滑均')
  if (!季节性与否 %in% c(TRUE, FALSE)) stop("季节性与否 = '是' 或 '否'")
  
  成品 <- llply(1:length(时间索引), function(迭数1) {
    
    if (迭数1 == 1) {
      cat('\n===========================================\n')
      cat('培训数据[', 迭数1, ']\n')
      print(培训数据 = 样本[日期 < 时间索引[迭数1]][(.N - (数据量 - 1)):.N])
      序列号 <- 培训数据$序列[1]:(range(培训数据$序列)[2] + 预测时间单位)
      
      cat('\n-------------------------------------------\n')
      cat('培训数据_测试数据[', 迭数1, ']\n')
      print(培训数据_测试数据 = 样本[序列 %in% 序列号])
      
      # 季回归 <- 培训数据[, .(年月日时分, 闭市价)] %>% 
      #   as.matrix %>% 
      #   tk_ts(frequency = 频率)
      季回归 <- 培训数据$闭市价 |> 
        {\(.) matrix(., dimnames = list(培训数据$年月日时分, '闭市价'))}() |> 
        {\(.) tk_ts(., frequency = 频率)}()
      rownames(季回归) <- 培训数据$年月日时分
      
      if (!.模型选项 %in% .模型选项表) {
        stop("错误信息：.模型选项表 = '自动化'或'自回归滑均'")
        
      } else {
        if (.模型选项 == '自动化') {
          季回归 <- tryCatch({
            auto.arima(
              季回归, d = .差分阶数, D = .季节性差分阶数, seasonal = 季节性与否, 
              stationary = 静态与否, trace = 记载自回归与否, 
              ic = 信息量准则, stepwise = 逐步精化与否, nmodels = 逐步精化量, 
              #approximation = 近似值与否, 
              method = 计策谋略, truncate = 缩写, #x = y, 
              xreg = 趋势, test = 测试, lambda = 博克斯考克斯变换, 
              test.args = 测试参数, allowdrift = 允许截距与否, 
              seasonal.test = 季节性测试, seasonal.test.args = 季节性测试参数, 
              allowmean = 允许包含均值与否, biasadj = 偏差调整与否, 
              parallel = 多管齐下与否, num.cores = 核心量)
            }, 错误信息 = function(错误信息参数) NULL)
        }
        if (.模型选项 == '自回归滑均') {
            # 季回归 <- 培训数据[, .(年月日时分, 闭市价)] %>%  as.xts
            季回归 <- tryCatch({
              Arima(
                季回归, order = .时序规律, seasonal = .季节性规律参数, 
                xreg = 趋势, include.mean = 包含均值与否, 
                include.drift = 包含截距, #include.constant = 包含常数, 
                #model = 统计模型, lambda = 博克斯考克斯变换, x = y, 
                biasadj = 偏差调整与否, method = 计策谋略)
              }, 错误信息 = function(错误信息参数) NULL)
        }
      }
      
      if (!is.null(季回归)) {
        季回归 %<>% 
          forecast::forecast(h = 预测时间单位) |> 
        {\(.) tk_tbl(.)}() |> 
        {\(.) mutate_dt(
          ., 年月日时分 = 
            培训数据_测试数据[(.N - 预测时间单位 + 1):.N,]$年月日时分, 
          市场价 = 培训数据_测试数据[(.N - 预测时间单位 + 1):.N,]$闭市价)}() |> 
        {\(.) rename_dt_dt(., 预测价 = `Point Forecast`)}() |> 
        {\(.) select_dt_dt(., 年月日时分, 市场价, 预测价)}()
        
        cat('\n-------------------------------------------\n')
        cat('预测序列[', 迭数1, ']\n')
        print(季回归 %>% as.data.table)
      }
      
      if (!.模型选项 %in% .模型选项表) {
        stop("错误信息：.模型选项表 = '自动化'或'自回归滑均'")
        
      } else {
        if (.模型选项 == '自动化') {
          模型名称 <- paste0(
            .模型选项, '_差分阶数', .差分阶数, '_季节性差分阶数', 
            .季节性差分阶数, '_季节性与否=', 季节性与否, '_数据量', 数据量, 
            '_频率', 频率, '_预测时间单位', 预测时间单位, 
            '_', 培训数据$年月日时分[迭数1], 'CST.rds')
        }
        if (.模型选项 == '自回归滑均') {
          模型名称 <- paste0(
            .模型选项, '_自回归滑动平均', 
            paste(.时序规律, collapse = ''), '_季节性', 
            paste(.季节性规律参数, collapse = ''), '_', 数据量, '_', 
            预测时间单位, '_', 培训数据$年月日时分[迭数1], 'CST.rds')
        }
      }
      
      saveRDS(季回归, paste0(.蜀道仓库, 文件名, '_', 模型名称))
      cat('\n', 迭数1, '=', 模型名称, '\n\n')
      rm(季回归)
      
    } else if (迭数1 %in% seq(1, length(时间索引), by = 6)[-1]) {
      
      
    } else if (迭数1 == length(时间索引)) {
      
      
    } else  {
      
      最终序列 <- 样本[日期 < 时间索引[迭数1],][.N]$序列 + 1
      
      cat('\n===========================================\n')
      cat('培训数据[', 迭数1, ']\n')
      print(培训数据 = 样本[(最终序列 - 数据量 + 1):最终序列])
      序列号 <- 培训数据$序列[1]:(range(培训数据$序列)[2] + 预测时间单位)
      
      cat('\n-------------------------------------------\n')
      cat('培训数据_测试数据[', 迭数1, ']\n')
      print(培训数据_测试数据 = 样本[序列 %in% 序列号])
      
      # 季回归 <- 培训数据[, .(年月日时分, 闭市价)] %>% 
      #   as.matrix %>% 
      #   tk_ts(frequency = 频率)
      季回归 <- 培训数据$闭市价 |> 
        {\(.) matrix(., dimnames = list(培训数据$年月日时分, '闭市价'))}() |> 
        {\(.) tk_ts(., frequency = 频率)}()
      rownames(季回归) <- 培训数据$年月日时分
      
      if (.模型选项 == '自动化') {
        
        季回归 <- tryCatch({
          auto.arima(
            季回归, d = .差分阶数, D = .季节性差分阶数, seasonal = 季节性与否, 
            stationary = 静态与否, trace = 记载自回归与否, 
            ic = 信息量准则, stepwise = 逐步精化与否, nmodels = 逐步精化量, 
            #approximation = 近似值与否, 
            method = 计策谋略, truncate = 缩写, #x = y, 
            xreg = 趋势, test = 测试, lambda = 博克斯考克斯变换, 
            test.args = 测试参数, allowdrift = 允许截距与否, 
            seasonal.test = 季节性测试, 
            seasonal.test.args = 季节性测试参数, 
            allowmean = 允许包含均值与否, biasadj = 偏差调整与否, 
            parallel = 多管齐下与否, num.cores = 核心量)
        }, 错误信息 = function(错误信息参数) NULL)
        
      } else if (.模型选项 == '自回归滑均') {
        
        # 季回归 <- 培训数据[, .(年月日时分, 闭市价)] %>% 
        #   as.xts
        
        季回归 <- tryCatch({
          Arima(
            季回归, order = .时序规律, seasonal = .季节性规律参数, 
            xreg = 趋势, include.mean = 包含均值与否, 
            include.drift = 包含截距, 
            #include.constant = 包含常数, 
            #model = 统计模型, lambda = 博克斯考克斯变换, x = y, 
            biasadj = 偏差调整与否, method = 计策谋略)
        }, 错误信息 = function(错误信息参数) NULL)
        
      } else {
        
      }
      
      if (!is.null(季回归)) {
        
        季回归 %<>% 
          forecast::forecast(h = 预测时间单位) |> 
        {\(.) tk_tbl(.)}() |> 
        {\(.) mutate_dt(
          ., 年月日时分 = 
            培训数据_测试数据[(.N - 预测时间单位 + 1):.N,]$年月日时分, 
          市场价 = 培训数据_测试数据[(.N - 预测时间单位 + 1):.N,]$闭市价)}() |> 
        {\(.) rename_dt_dt(., 预测价 = `Point Forecast`)}() |> 
        {\(.) select_dt_dt(., 年月日时分, 市场价, 预测价)}()
        
        cat('\n-------------------------------------------\n')
        cat('预测序列[', 迭数1, ']\n')
        print(季回归 %>% as.data.table)
      }
      
      if (.模型选项 == '自动化') {
        
        模型名称 <- paste0(
          .模型选项, '_差分阶数', .差分阶数, '季节性差分阶数', 
          .季节性差分阶数, '_季节性与否=', 季节性与否, '_', 数据量, '_', 
          预测时间单位, '_', 培训数据$年月日时分[迭数1], 'CST.rds')
        
      } else if (.模型选项 == '自回归滑均') {
        模型名称 <- paste0(
          .模型选项, '_自回归滑动平均', paste(.时序规律, collapse = ''), 
          '_季节性', paste(.季节性规律参数, collapse = ''), '_', 数据量, '_', 
          预测时间单位, '_', 培训数据$年月日时分[迭数1], 'CST.rds')
        
      } else {
        
      }
      
      saveRDS(季回归, paste0(.蜀道仓库, 文件名, '_', 模型名称))
      cat('\n', 迭数1, '=', 模型名称, '\n\n')
      rm(季回归)
    }
  })
  return(成品)
}
